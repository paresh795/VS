# Task ID: 5
# Title: Implement Empty Room Generation (Plan B Fallback)
# Status: pending
# Dependencies: 3, 4
# Priority: medium
# Description: Create the fallback mechanism using mask-guided ControlNet inpainting when Plan A fails to remove furniture completely.
# Details:
1. Create a function to analyze Plan A results for furniture remnants
   ```typescript
   async function detectFurnitureRemnants(emptyRoomUrl) {
     // Use Lang-SAM again to check if furniture is still detected
     const prediction = await replicate.run(
       "tmappdev/lang-segment-anything:891411c3...",
       { input: { image: emptyRoomUrl, text_prompt: "sofa,chair,table,lamp" } }
     );
     
     // Analyze mask coverage to determine if furniture remains
     const maskCoverage = await analyzeMaskCoverage(prediction.output);
     return maskCoverage > 0.05; // If more than 5% is detected as furniture
   }
   ```
2. Extend the empty room API to implement Plan B fallback:
   ```typescript
   // In pages/api/empty.ts
   // After Plan A completion:
   const furnitureRemains = await detectFurnitureRemnants(prediction.output[0]);
   
   if (furnitureRemains) {
     // Plan B: Use mask-guided inpainting
     const maskUrl = await getMaskForImage(imageUrl);
     
     const planBPrediction = await replicate.run(
       "black-forest-labs/flux-kontext-pro",
       { 
         input: {
           input_image: getPublicUrl(imageUrl),
           mask_image: maskUrl,
           prompt: "Remove all white areas; keep remaining pixels unchanged.",
           aspect_ratio: "match_input_image",
           output_format: "jpg"
         }
       }
     );
     
     // Update job with Plan B result
     await db.update(jobs)
       .set({ 
         status: 'completed', 
         resultUrl: planBPrediction.output[0],
         metadata: { usedFallback: true }
       })
       .where(eq(jobs.id, job[0].id));
     
     return res.status(200).json({ 
       jobId: job[0].id, 
       emptyRoomUrl: planBPrediction.output[0],
       usedFallback: true
     });
   }
   ```
3. Add logging for Plan A vs Plan B usage
4. Implement UI indicator for fallback usage

# Test Strategy:
1. Test furniture remnant detection with various Plan A outputs
2. Verify Plan B fallback triggers correctly
3. Compare Plan A and Plan B results for quality
4. Measure SSIM scores for both approaches
5. Test with challenging images (complex furniture, unusual lighting)
6. Verify proper logging of fallback usage

# Subtasks:
## 1. Implement Furniture Remnant Detection System [pending]
### Dependencies: None
### Description: Create a robust system to analyze Plan A results and detect if furniture items still remain in the supposedly empty room image.
### Details:
1. Implement the `detectFurnitureRemnants` function that uses Lang-SAM to identify furniture items
2. Create the `analyzeMaskCoverage` helper function to calculate the percentage of the image covered by furniture masks
3. Set appropriate threshold values for determining when furniture is considered to remain (default 5%)
4. Add caching for Lang-SAM results to improve performance
5. Include error handling for API failures

## 2. Develop Mask Generation for Inpainting [pending]
### Dependencies: None
### Description: Create a system to generate appropriate masks for the inpainting process that will target furniture areas for removal.
### Details:
1. Implement the `getMaskForImage` function that converts Lang-SAM furniture detection results into binary masks
2. Ensure masks properly highlight all furniture areas that need removal
3. Add mask dilation/expansion options to ensure complete furniture removal
4. Implement mask validation to prevent processing errors
5. Add mask preview capability for debugging

## 3. Integrate Flux Kontext-Pro for Inpainting [pending]
### Dependencies: None
### Description: Set up the integration with the Flux Kontext-Pro model to perform mask-guided inpainting for furniture removal.
### Details:
1. Configure the Replicate API call to the Flux Kontext-Pro model
2. Optimize prompt engineering for empty room generation
3. Handle image format conversions and URL management
4. Implement retry logic for API failures
5. Add timeout handling for long-running inpainting operations

## 4. Implement Plan B Fallback Logic in API [pending]
### Dependencies: None
### Description: Extend the empty room API to implement the conditional fallback to Plan B when Plan A fails to completely remove furniture.
### Details:
1. Modify the API route to check Plan A results using the furniture detection system
2. Implement conditional logic to trigger Plan B when needed
3. Update database schema to track which plan was used
4. Add appropriate status updates throughout the process
5. Ensure proper error handling and client feedback

## 5. Add Logging, Monitoring and UI Indicators [pending]
### Dependencies: None
### Description: Implement comprehensive logging, monitoring, and UI feedback for the fallback system to track usage patterns and inform users.
### Details:
1. Add detailed logging for Plan A vs Plan B usage statistics
2. Implement UI indicators to show when fallback was used
3. Create a simple dashboard to monitor fallback frequency
4. Add quality comparison metrics between Plan A and Plan B results
5. Implement user feedback collection for results quality

